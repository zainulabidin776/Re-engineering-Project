\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{float}

\geometry{margin=1in}
\pagestyle{fancy}
\fancyhf{}
\rhead{Software Reengineering Project}
\lhead{SG Technologies POS System}
\cfoot{\thepage}

\titleformat{\section}
{\Large\bfseries}
{}
{0em}
{}[\titlerule]

\lstset{
    language=Java,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=2
}

\title{
    \textbf{Software Reengineering Project}\\
    \large Reengineering Legacy POS System to Modern Web Application
}
\author{
    Muhammad Yousuf Khan (21i-1238)\\
    Zain Ul Abidin (22i-2738)\\
    Abad Naseer (20i-1815)
}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\newpage
\tableofcontents
\newpage

\section{Executive Summary}

This document presents a comprehensive report on the software reengineering project of the SG Technologies Point-of-Sale (POS) system. The project involved transforming a legacy desktop-based Java application into a modern, web-based system following the Software Reengineering Process Model. The reengineered system utilizes Spring Boot for the backend, React with TypeScript for the frontend, and PostgreSQL for data storage.

\subsection{Project Objectives}
\begin{itemize}
    \item Analyze and document the legacy system architecture
    \item Restructure code to improve maintainability
    \item Migrate from file-based storage to relational database
    \item Implement modern web-based architecture
    \item Ensure feature parity with legacy system
    \item Improve security, scalability, and user experience
\end{itemize}

\subsection{Key Achievements}
\begin{itemize}
    \item Successfully completed all 6 phases of reengineering process
    \item Eliminated 130+ lines of duplicate code
    \item Designed normalized database schema with 11 tables
    \item Implemented complete REST API with 15+ endpoints
    \item Built modern React frontend with Material-UI
    \item Achieved 100\% feature parity with legacy system
    \item Created comprehensive test suite with 30+ backend tests and frontend tests
    \item Configured H2 in-memory database for isolated testing
    \item Achieved approximately 60\% overall test coverage
\end{itemize}

\section{Introduction}

\subsection{Project Background}

The SG Technologies POS system was originally developed as a desktop application using Java Swing for the user interface and plain text files for data storage. While functional, the system suffered from several limitations:

\begin{itemize}
    \item \textbf{Single-user limitation}: Desktop application restricted to one user at a time
    \item \textbf{File-based storage}: Data stored in text files without proper relationships
    \item \textbf{Security concerns}: Plain text password storage
    \item \textbf{Maintainability issues}: Code duplication, magic numbers, tight coupling
    \item \textbf{No scalability}: Cannot handle concurrent transactions efficiently
\end{itemize}

\subsection{Reengineering Goals}

The reengineering project aimed to address these limitations by:

\begin{enumerate}
    \item \textbf{Modernizing architecture}: Transition to web-based, multi-user system
    \item \textbf{Improving data management}: Migrate to normalized relational database
    \item \textbf{Enhancing security}: Implement JWT authentication and password hashing
    \item \textbf{Refactoring code}: Eliminate duplication and improve maintainability
    \item \textbf{Improving UX}: Modern web interface with better usability
\end{enumerate}

\section{Reengineering Process Model}

The project followed the Software Reengineering Process Model, which consists of six distinct phases:

\subsection{Phase 1: Inventory Analysis}

\subsubsection{Objectives}
The inventory analysis phase involved cataloging all assets of the legacy system, including source code files, data files, documentation, and dependencies.

\subsubsection{Findings}
\begin{itemize}
    \item \textbf{Source Code}: 20 Java classes totaling approximately 3,000 lines of code
    \item \textbf{Data Files}: 9 text-based database files storing different entities
    \item \textbf{Test Coverage}: Less than 5\% test coverage
    \item \textbf{Dependencies}: Minimal external dependencies, mostly Java standard library
\end{itemize}

\subsubsection{Asset Classification}
Assets were classified into three categories:
\begin{itemize}
    \item \textbf{Keep}: Core business logic, domain models
    \item \textbf{Refactor}: Classes with code smells, duplicate code
    \item \textbf{Replace}: File I/O operations, Swing UI components
\end{itemize}

\subsection{Phase 2: Document Restructuring}

\subsubsection{Objectives}
Reorganize and enhance documentation to support the reengineering effort.

\subsubsection{Deliverables}
\begin{itemize}
    \item Data dictionary for all file formats
    \item Operational scenarios and use cases
    \item Architecture diagrams
    \item API documentation structure
\end{itemize}

\subsection{Phase 3: Reverse Engineering}

\subsubsection{Architecture Analysis}

The legacy system followed a layered architecture with the following components:

\begin{enumerate}
    \item \textbf{Presentation Layer}: Swing-based GUI components
    \item \textbf{Business Logic Layer}: Core POS operations (Sales, Rentals, Returns)
    \item \textbf{Data Access Layer}: File I/O operations for data persistence
\end{enumerate}

\subsubsection{Code Smells Identified}

\begin{enumerate}
    \item \textbf{God Classes}: POSSystem, PointOfSale, Management classes with excessive responsibilities
    \item \textbf{Long Methods}: Methods exceeding 80 lines of code
    \item \textbf{Code Duplication}: deleteTempItem method duplicated in 3 classes
    \item \textbf{Magic Numbers}: Hardcoded values throughout the codebase
    \item \textbf{Feature Envy}: Classes accessing data from other classes excessively
    \item \textbf{Data Clumps}: Related data not grouped into objects
    \item \textbf{Primitive Obsession}: Using primitives instead of value objects
    \item \textbf{Inappropriate Intimacy}: Classes knowing too much about each other
    \item \textbf{Lazy Class}: Classes with minimal functionality
    \item \textbf{Speculative Generality}: Over-abstracted code
\end{enumerate}

\subsubsection{Data Smells Identified}

\begin{itemize}
    \item \textbf{Denormalized Data}: Customer and rental data mixed in single file
    \item \textbf{No Referential Integrity}: No foreign key relationships
    \item \textbf{Inconsistent Formats}: Mix of space and comma delimiters
    \item \textbf{No Data Validation}: No constraints on data values
\end{itemize}

\subsection{Phase 4: Code Restructuring}

\subsubsection{Refactoring Activities}

Ten major refactorings were performed:

\begin{enumerate}
    \item \textbf{Extract Constants Class}: Centralized 20+ magic numbers and strings
    \item \textbf{Extract SystemUtils Class}: Consolidated OS detection and line separator logic
    \item \textbf{Apply Constants to POSSystem}: Replaced hardcoded file paths
    \item \textbf{Apply Constants to PointOfSale}: Replaced magic values
    \item \textbf{Apply Constants to POS}: Updated sale-related constants
    \item \textbf{Apply Constants to POR}: Updated rental-related constants
    \item \textbf{Apply Constants to POH}: Updated return-related constants
    \item \textbf{Apply Constants to Management}: Updated user database constants
    \item \textbf{Apply Constants to EmployeeManagement}: Updated employee constants
    \item \textbf{Extract Duplicate Method}: Consolidated deleteTempItem into base class
\end{enumerate}

\subsubsection{Results}

\begin{itemize}
    \item Eliminated approximately 130 lines of duplicate code
    \item Centralized all magic values in Constants class
    \item Improved code maintainability and readability
    \item Zero behavior changes (safe refactorings)
    \item All tests passing after refactoring
\end{itemize}

\subsection{Phase 5: Data Restructuring}

\subsubsection{Database Design}

A normalized PostgreSQL schema was designed with 11 tables:

\begin{enumerate}
    \item \textbf{employees}: Employee accounts and authentication
    \item \textbf{items}: Inventory items with pricing
    \item \textbf{customers}: Customer information
    \item \textbf{coupons}: Discount codes
    \item \textbf{sales}: Sales transactions
    \item \textbf{sale\_items}: Items in each sale
    \item \textbf{rentals}: Rental transactions
    \item \textbf{rental\_items}: Items in each rental
    \item \textbf{returns}: Return transactions
    \item \textbf{return\_items}: Items in each return
    \item \textbf{audit\_logs}: System audit trail
\end{enumerate}

\subsubsection{Normalization}

The schema follows Third Normal Form (3NF):
\begin{itemize}
    \item No repeating groups
    \item No partial dependencies
    \item No transitive dependencies
    \item Proper foreign key relationships
\end{itemize}

\subsubsection{Data Migration Strategy}

A migration utility was developed to:
\begin{enumerate}
    \item Parse legacy text files
    \item Transform data to normalized structure
    \item Load data into PostgreSQL
    \item Validate data integrity
\end{enumerate}

\subsection{Phase 6: Forward Engineering}

\subsubsection{Technology Stack Selection}

\textbf{Backend:}
\begin{itemize}
    \item Spring Boot 3.2.0
    \item Spring Data JPA
    \item Spring Security with JWT
    \item PostgreSQL
    \item Maven
\end{itemize}

\textbf{Frontend:}
\begin{itemize}
    \item React 18.2
    \item TypeScript 5.3
    \item Material-UI 5.14
    \item Vite 5.0
    \item Axios 1.6
\end{itemize}

\subsubsection{Architecture Design}

The reengineered system follows a layered architecture:

\begin{enumerate}
    \item \textbf{Presentation Layer}: React components with Material-UI
    \item \textbf{API Layer}: Spring Boot REST controllers
    \item \textbf{Business Logic Layer}: Spring services
    \item \textbf{Data Access Layer}: Spring Data JPA repositories
    \item \textbf{Database Layer}: PostgreSQL
\end{enumerate}

\subsubsection{Key Features Implemented}

\begin{itemize}
    \item JWT-based authentication
    \item Role-based access control (Admin/Cashier)
    \item Sales processing with tax and coupon support
    \item Rental management with customer lookup
    \item Return processing with overdue tracking
    \item Inventory management
    \item Employee management (Admin only)
\end{itemize}

\section{Implementation Details}

\subsection{Backend Implementation}

\subsubsection{Entity Design}

JPA entities were created for all database tables with proper relationships:

\begin{lstlisting}[caption=Employee Entity Example]
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(unique = true, nullable = false)
    private String username;
    
    @Column(nullable = false)
    private String position; // Admin or Cashier
    
    @Column(name = "password_hash", nullable = false)
    private String passwordHash;
    
    // Getters and setters
}
\end{lstlisting}

\subsubsection{Service Layer}

Business logic was implemented in service classes:

\begin{lstlisting}[caption=Sale Service Example]
@Service
public class SaleService {
    @Transactional
    public Sale processSale(UUID employeeId, SaleRequest request) {
        // Calculate totals
        // Update inventory
        // Apply tax and discounts
        // Save transaction
    }
}
\end{lstlisting}

\subsubsection{API Endpoints}

RESTful endpoints were created for all operations:

\begin{itemize}
    \item \texttt{POST /api/auth/login} - Authentication
    \item \texttt{POST /api/sales} - Process sale
    \item \texttt{POST /api/rentals} - Process rental
    \item \texttt{POST /api/returns} - Process return
    \item \texttt{GET /api/items} - Get inventory
    \item \texttt{GET /api/employees} - Employee management
\end{itemize}

\subsection{Frontend Implementation}

\subsubsection{Component Structure}

React components were organized into:
\begin{itemize}
    \item \textbf{Pages}: Login, CashierDashboard, AdminDashboard
    \item \textbf{Components}: SalesPage, RentalsPage, ReturnsPage, etc.
    \item \textbf{Services}: API service layer
    \item \textbf{Context}: Authentication context
\end{itemize}

\subsubsection{Authentication Flow}

\begin{enumerate}
    \item User enters credentials on login page
    \item Frontend sends POST request to /api/auth/login
    \item Backend validates credentials and returns JWT token
    \item Token stored in localStorage
    \item Token included in all subsequent API requests
    \item Protected routes check authentication status
\end{enumerate}

\section{Testing}

\subsection{Testing Strategy}

A comprehensive testing strategy was implemented covering unit tests, integration tests, and end-to-end API tests. The test suite ensures reliability and maintainability of the reengineered system.

\subsection{Backend Testing}

JUnit 5 tests were created with comprehensive coverage:

\begin{itemize}
    \item \textbf{Controller Tests}: Authentication controller with MockMvc
    \item \textbf{Service Tests}: Sale, Rental, Return, Employee, and Inventory services
    \item \textbf{Repository Tests}: Item and Customer repository queries
    \item \textbf{Integration Tests}: Complete sale workflow with coupon application
\end{itemize}

\subsubsection{Test Configuration}

Tests are configured to use H2 in-memory database for isolation:
\begin{itemize}
    \item H2 database dependency added for test scope
    \item Test profile configuration (\texttt{application-test.properties})
    \item \texttt{@ActiveProfiles("test")} annotation on all test classes
    \item JWT configuration for test environment
    \item Transaction rollback after each test
\end{itemize}

\subsubsection{Test Coverage}

The backend test suite includes:
\begin{itemize}
    \item 30+ test methods covering all critical paths
    \item Service layer: 100\% coverage of business logic
    \item Repository layer: All query methods tested
    \item Controller layer: Authentication and error handling
    \item Integration tests: End-to-end workflows
\end{itemize}

\subsection{Frontend Testing}

React Testing Library with Vitest tests were created for:

\begin{itemize}
    \item \textbf{Component Tests}: Login component with form validation
    \item \textbf{Context Tests}: Authentication context and state management
    \item \textbf{Service Tests}: API service layer mocking
    \item \textbf{Integration Tests}: Component interaction and user flows
\end{itemize}

\subsubsection{Test Configuration}

Frontend tests use:
\begin{itemize}
    \item Vitest as the test runner (replacing Jest)
    \item React Testing Library for component testing
    \item jsdom environment for DOM simulation
    \item Mock service layer for API calls
\end{itemize}

\subsection{API Testing}

Comprehensive API testing scripts were created:

\begin{itemize}
    \item \textbf{PowerShell Scripts}: Windows-compatible integration tests
    \item \textbf{Bash Scripts}: Linux/Mac end-to-end test suites
    \item \textbf{Integration Tests}: Complete workflows (login, sales, rentals, returns)
    \item \textbf{Manual Testing}: Postman collection for API exploration
\end{itemize}

\subsubsection{Test Scenarios}

API tests cover:
\begin{itemize}
    \item Authentication and authorization flows
    \item Sales processing with multiple items and coupons
    \item Rental creation and customer management
    \item Return processing with inventory restoration
    \item Inventory management operations
    \item Employee management (Admin only)
\end{itemize}

\section{Results and Improvements}

\subsection{Code Quality Improvements}

\begin{itemize}
    \item \textbf{Code Duplication}: Reduced by 130+ lines
    \item \textbf{Maintainability}: Improved through centralized constants
    \item \textbf{Test Coverage}: Increased from <5\% to approximately 60\% overall coverage
    \begin{itemize}
        \item Backend: 30+ test methods covering services, controllers, and repositories
        \item Frontend: Component and context tests with Vitest
        \item Integration: End-to-end API test scripts
    \end{itemize}
    \item \textbf{Documentation}: 10+ comprehensive markdown documents
    \item \textbf{Test Infrastructure}: H2 in-memory database for isolated testing
\end{itemize}

\subsection{Architecture Improvements}

\begin{itemize}
    \item \textbf{Scalability}: Multi-user web application vs. single-user desktop
    \item \textbf{Maintainability}: Layered architecture with clear separation
    \item \textbf{Testability}: Dependency injection enables unit testing
    \item \textbf{Extensibility}: Easy to add new features
\end{itemize}

\subsection{Data Management Improvements}

\begin{itemize}
    \item \textbf{Normalization}: Proper relational structure
    \item \textbf{Integrity}: Foreign key constraints
    \item \textbf{Concurrency}: Database transactions
    \item \textbf{Performance}: Indexed queries
\end{itemize}

\subsection{Security Improvements}

\begin{itemize}
    \item \textbf{Authentication}: JWT tokens vs. plain text
    \item \textbf{Password Storage}: BCrypt hashing
    \item \textbf{Authorization}: Role-based access control
    \item \textbf{API Security}: Protected endpoints
\end{itemize}

\section{Challenges and Solutions}

\subsection{Challenge 1: Data Migration}

\textbf{Problem}: Migrating data from text files to normalized database.

\textbf{Solution}: Created DataMigrationUtil class to parse files and transform data.

\subsection{Challenge 2: Legacy Code Understanding}

\textbf{Problem}: Understanding legacy code structure and business logic.

\textbf{Solution}: Comprehensive reverse engineering analysis and documentation.

\subsection{Challenge 3: Feature Parity}

\textbf{Problem}: Ensuring all legacy features work in new system.

\textbf{Solution}: Detailed feature mapping and comprehensive testing.

\subsection{Challenge 4: Test Configuration}

\textbf{Problem}: Initial test failures due to ApplicationContext loading issues. Tests were attempting to connect to PostgreSQL database which may not be available during test execution.

\textbf{Solution}: 
\begin{itemize}
    \item Configured H2 in-memory database for test environment
    \item Created test profile with \texttt{application-test.properties}
    \item Added \texttt{@ActiveProfiles("test")} to all test classes
    \item Configured JWT properties for test environment
    \item Tests now run independently without external database dependency
\end{itemize}

\subsection{Challenge 5: Spring Data JPA Query Method Naming}

\textbf{Problem}: Repository method \texttt{findByQuantityLessThanOrEqual} caused ApplicationContext loading failure with error: "No property 'equal' found for type 'Item'".

\textbf{Solution}: 
\begin{itemize}
    \item Identified that Spring Data JPA does not support \texttt{LessThanOrEqual} keyword
    \item Changed method name to \texttt{findByQuantityLessThanEqual} (removed "Or")
    \item Updated service layer to use corrected method name
    \item All tests now pass successfully
\end{itemize}

\section{Conclusion}

The software reengineering project successfully transformed the legacy POS system into a modern, web-based application. All six phases of the reengineering process were completed, resulting in:

\begin{itemize}
    \item Improved code quality and maintainability
    \item Modern web-based architecture
    \item Secure authentication and authorization
    \item Normalized database structure
    \item Enhanced user experience
    \item Comprehensive documentation
\end{itemize}

The reengineered system maintains feature parity with the legacy system while providing significant improvements in scalability, security, and maintainability.

\section{Future Work}

Potential enhancements for future iterations:

\begin{itemize}
    \item Increase test coverage to 80\%+ with additional edge case tests
    \item Implement reporting and analytics features
    \item Add mobile application support (React Native)
    \item Implement real-time inventory updates with WebSockets
    \item Add barcode scanning support
    \item Implement loyalty program features
    \item Add automated CI/CD pipeline with test execution
    \item Implement performance testing and optimization
    \item Add comprehensive API documentation with Swagger/OpenAPI
\end{itemize}

\section{System Screenshots}

This section provides visual documentation of the reengineered POS system, showcasing the user interface, functionality, and system operations.

\subsection{Backend and Terminal Operations}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{screenshots/terminal.png}
    \caption{Backend Server Terminal Output: Spring Boot application running on port 8081, showing database connection, table creation, and successful startup. The terminal displays Hibernate SQL queries, JPA entity initialization, and security configuration.}
    \label{fig:terminal}
\end{figure}

\subsection{Test Execution}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{screenshots/test1.png}
    \caption{Test Results: Comprehensive test suite execution showing successful test runs for backend services, repositories, and controllers. Tests are configured with H2 in-memory database for isolated testing.}
    \label{fig:test1}
\end{figure}

\subsection{Admin Dashboard}

The Admin dashboard provides comprehensive system management capabilities including employee management, inventory control, and system oversight.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{screenshots/admin1.png}
    \caption{Admin Dashboard - Main View: Overview of the admin interface showing navigation menu with access to Employee Management, Inventory Management, and system administration features. The dashboard provides role-based access control for administrative functions.}
    \label{fig:admin1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{screenshots/admin2.png}
    \caption{Admin Dashboard - Employee Management: Interface for managing employee accounts, including adding new employees, updating existing records, and managing user roles (Admin/Cashier). The system supports secure password hashing and role-based permissions.}
    \label{fig:admin2}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{screenshots/admin3.png}
    \caption{Admin Dashboard - Inventory Management: Complete inventory control interface allowing admins to view all items, update quantities, modify prices, and manage product information. The interface provides real-time inventory status and low-stock alerts.}
    \label{fig:admin3}
\end{figure}

\subsection{Cashier Dashboard}

The Cashier dashboard is designed for day-to-day transaction processing, providing streamlined interfaces for sales, rentals, and returns.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{screenshots/cashier1.png}
    \caption{Cashier Dashboard - Main View: Cashier interface showing the main navigation with access to Sales, Rentals, and Returns modules. The dashboard is optimized for fast transaction processing with intuitive Material-UI components.}
    \label{fig:cashier1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{screenshots/cashier2.png}
    \caption{Cashier Dashboard - Sales Processing: Sales transaction interface displaying item selection, quantity input, coupon application, and real-time total calculation including tax. The interface supports multiple items per transaction with automatic inventory updates.}
    \label{fig:cashier2}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{screenshots/cashier3.png}
    \caption{Cashier Dashboard - Rental Management: Rental transaction interface showing customer lookup, item selection for rental, due date configuration, and rental total calculation. The system tracks rental periods and manages return dates automatically.}
    \label{fig:cashier3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{screenshots/cashier4.png}
    \caption{Cashier Dashboard - Return Processing: Return transaction interface for processing item returns from rentals. The system calculates refund amounts, tracks overdue items, and automatically restores inventory quantities upon return completion.}
    \label{fig:cashier4}
\end{figure}

\subsection{User Interface Features}

The reengineered system features a modern, responsive web interface built with React and Material-UI:

\begin{itemize}
    \item \textbf{Responsive Design}: Adapts to different screen sizes and devices
    \item \textbf{Intuitive Navigation}: Clear menu structure with role-based access
    \item \textbf{Real-time Updates}: Live inventory and transaction status
    \item \textbf{Error Handling}: User-friendly error messages and validation
    \item \textbf{Accessibility}: WCAG-compliant interface elements
    \item \textbf{Performance}: Fast page loads and smooth interactions
\end{itemize}

\section{References}

\begin{itemize}
    \item Software Reengineering Process Model
    \item Spring Boot Documentation: \url{https://spring.io/projects/spring-boot}
    \item React Documentation: \url{https://react.dev}
    \item PostgreSQL Documentation: \url{https://www.postgresql.org/docs}
    \item Project Repository: \url{https://github.com/zainulabidin776/Re-engineering-Project}
\end{itemize}

\appendix

\section{Appendix A: Database Schema}

\subsection{Schema Overview}

The complete database schema DDL is available in \texttt{Database/schema.sql}. This file contains the Data Definition Language (DDL) script for the PostgreSQL database schema, including all 11 tables, their relationships, constraints, and indexes. The schema follows Third Normal Form (3NF) normalization principles and includes proper foreign key relationships for data integrity.

\subsection{Table Structure}

The database schema consists of the following tables:

\begin{enumerate}
    \item \textbf{employees}: Stores employee authentication and profile information
    \begin{itemize}
        \item Primary Key: \texttt{id} (UUID)
        \item Unique Constraints: \texttt{username}
        \item Fields: username, first\_name, last\_name, position, password\_hash, created\_at, updated\_at
        \item Relationships: Referenced by sales, rentals, and returns tables
    \end{itemize}
    
    \item \textbf{items}: Inventory items with pricing and quantity information
    \begin{itemize}
        \item Primary Key: \texttt{id} (UUID)
        \item Unique Constraints: \texttt{item\_id} (business identifier)
        \item Fields: item\_id, name, price, quantity, created\_at, updated\_at
        \item Relationships: Referenced by sale\_items, rental\_items
    \end{itemize}
    
    \item \textbf{customers}: Customer information for rentals and returns
    \begin{itemize}
        \item Primary Key: \texttt{id} (UUID)
        \item Unique Constraints: \texttt{phone}
        \item Fields: first\_name, last\_name, phone, email, created\_at, updated\_at
        \item Relationships: Referenced by rentals table
    \end{itemize}
    
    \item \textbf{coupons}: Discount codes for sales transactions
    \begin{itemize}
        \item Primary Key: \texttt{id} (UUID)
        \item Unique Constraints: \texttt{code}
        \item Fields: code, discount\_percent, active, valid\_from, valid\_to, created\_at
    \end{itemize}
    
    \item \textbf{sales}: Sales transaction records
    \begin{itemize}
        \item Primary Key: \texttt{id} (UUID)
        \item Foreign Keys: employee\_id → employees
        \item Fields: transaction\_date, total\_amount, tax\_amount, discount\_amount, final\_total, coupon\_code, created\_at
        \item Relationships: One-to-many with sale\_items
    \end{itemize}
    
    \item \textbf{sale\_items}: Individual items in sales transactions
    \begin{itemize}
        \item Primary Key: \texttt{id} (UUID)
        \item Foreign Keys: sale\_id → sales, item\_id → items
        \item Fields: quantity, unit\_price, subtotal, created\_at
    \end{itemize}
    
    \item \textbf{rentals}: Rental transaction records
    \begin{itemize}
        \item Primary Key: \texttt{id} (UUID)
        \item Foreign Keys: employee\_id → employees, customer\_id → customers
        \item Fields: rental\_date, due\_date, total\_amount, tax\_amount, created\_at
        \item Relationships: One-to-many with rental\_items, one-to-many with returns
    \end{itemize}
    
    \item \textbf{rental\_items}: Individual items in rental transactions
    \begin{itemize}
        \item Primary Key: \texttt{id} (UUID)
        \item Foreign Keys: rental\_id → rentals, item\_id → items
        \item Fields: quantity, unit\_price, returned, return\_date, days\_overdue, created\_at
    \end{itemize}
    
    \item \textbf{returns}: Return transaction records
    \begin{itemize}
        \item Primary Key: \texttt{id} (UUID)
        \item Foreign Keys: rental\_id → rentals, employee\_id → employees
        \item Fields: return\_date, total\_refund, created\_at
        \item Relationships: One-to-many with return\_items
    \end{itemize}
    
    \item \textbf{return\_items}: Individual items in return transactions
    \begin{itemize}
        \item Primary Key: \texttt{id} (UUID)
        \item Foreign Keys: return\_id → returns, rental\_item\_id → rental\_items
        \item Fields: quantity, refund\_amount, created\_at
    \end{itemize}
\end{enumerate}

\subsection{Normalization Details}

The schema achieves Third Normal Form (3NF) through:

\begin{itemize}
    \item \textbf{Elimination of Repeating Groups}: Transaction items stored in separate tables (sale\_items, rental\_items, return\_items)
    \item \textbf{Removal of Partial Dependencies}: All non-key attributes fully depend on primary keys
    \item \textbf{Removal of Transitive Dependencies}: No indirect dependencies between attributes
    \item \textbf{Referential Integrity}: Foreign key constraints ensure data consistency
    \item \textbf{Unique Constraints}: Prevent duplicate business identifiers (usernames, item IDs, phone numbers)
\end{itemize}

\subsection{Indexes and Performance}

The schema includes indexes on:
\begin{itemize}
    \item Foreign key columns for faster joins
    \item Unique constraint columns (username, item\_id, phone, code)
    \item Frequently queried columns (rental\_date, due\_date, transaction\_date)
\end{itemize}

\subsection{Data Types}

\begin{itemize}
    \item \textbf{UUID}: Used for all primary keys to ensure global uniqueness
    \item \textbf{NUMERIC(10,2)}: Monetary values (prices, totals, taxes)
    \item \textbf{NUMERIC(5,2)}: Percentage values (discount percentages)
    \item \textbf{VARCHAR}: Variable-length strings with appropriate size limits
    \item \textbf{BOOLEAN}: Flags for active status, returned status
    \item \textbf{TIMESTAMP}: Date and time fields with timezone support
    \item \textbf{DATE}: Date-only fields (due dates, return dates)
\end{itemize}

\subsection{Migration from Legacy System}

The migration process transforms legacy text file data into the normalized schema:
\begin{itemize}
    \item Employee data from \texttt{employeeDatabase.txt} → \texttt{employees} table
    \item Item data from \texttt{itemDatabase.txt} → \texttt{items} table
    \item Coupon codes from \texttt{couponNumber.txt} → \texttt{coupons} table
    \item Transaction data parsed and split into parent and child tables
    \item Passwords hashed using BCrypt before storage
    \item UUIDs generated for all new records
\end{itemize}

\section{Appendix B: API Documentation}

\subsection{API Overview}

The reengineered POS system provides a comprehensive RESTful API built with Spring Boot. All endpoints are prefixed with \texttt{/api} and follow REST conventions. The API uses JWT (JSON Web Tokens) for authentication and returns JSON responses.

\subsection{Base URL}

\begin{itemize}
    \item Development: \texttt{http://localhost:8081/api}
    \item Production: \texttt{https://api.sgtech-pos.com/api}
\end{itemize}

\subsection{Authentication}

All endpoints except authentication and migration require a valid JWT token in the Authorization header:

\begin{lstlisting}[caption=Authentication Header Format]
Authorization: Bearer <jwt_token>
X-Employee-Id: <employee_uuid>
\end{lstlisting}

\subsection{API Endpoints}

\subsubsection{Authentication Endpoints}

\begin{itemize}
    \item \textbf{POST /api/auth/login}
    \begin{itemize}
        \item Description: Authenticate user and receive JWT token
        \item Request Body: \texttt{\{username: string, password: string\}}
        \item Response: \texttt{\{token: string, employeeId: string, username: string, fullName: string, position: string\}}
        \item Status Codes: 200 (success), 400 (invalid credentials)
        \item Example:
        \begin{lstlisting}
POST /api/auth/login
{
  "username": "110001",
  "password": "1"
}
        \end{lstlisting}
    \end{itemize}
    
    \item \textbf{GET /api/auth/health}
    \begin{itemize}
        \item Description: Health check endpoint
        \item Response: \texttt{"Auth service is running"}
        \item Authentication: Not required
    \end{itemize}
\end{itemize}

\subsubsection{Sales Endpoints}

\begin{itemize}
    \item \textbf{POST /api/sales}
    \begin{itemize}
        \item Description: Process a new sale transaction
        \item Request Body: \texttt{\{items: Array<\{itemId: number, quantity: number\}>, couponCode?: string\}}
        \item Response: Complete sale object with calculated totals
        \item Authentication: Required (JWT token)
        \item Business Logic: Calculates subtotal, applies tax (8.25\%), applies coupon discount if valid, updates inventory quantities
    \end{itemize}
    
    \item \textbf{GET /api/sales}
    \begin{itemize}
        \item Description: Retrieve all sales transactions
        \item Response: Array of sale objects
        \item Authentication: Required (Admin only)
    \end{itemize}
    
    \item \textbf{GET /api/sales/\{id\}}
    \begin{itemize}
        \item Description: Retrieve specific sale by ID
        \item Response: Sale object with sale\_items
        \item Authentication: Required
    \end{itemize}
\end{itemize}

\subsubsection{Rental Endpoints}

\begin{itemize}
    \item \textbf{POST /api/rentals}
    \begin{itemize}
        \item Description: Create a new rental transaction
        \item Request Body: \texttt{\{customerPhone: string, items: Array<\{itemId: number, quantity: number\}>, dueDate: string\}}
        \item Response: Complete rental object
        \item Authentication: Required
        \item Business Logic: Creates or finds customer, calculates rental total, sets due date, updates inventory
    \end{itemize}
    
    \item \textbf{GET /api/rentals}
    \begin{itemize}
        \item Description: Retrieve all rental transactions
        \item Response: Array of rental objects
        \item Authentication: Required
    \end{itemize}
    
    \item \textbf{GET /api/rentals/\{id\}}
    \begin{itemize}
        \item Description: Retrieve specific rental by ID
        \item Response: Rental object with rental\_items
        \item Authentication: Required
    \end{itemize}
\end{itemize}

\subsubsection{Return Endpoints}

\begin{itemize}
    \item \textbf{POST /api/returns}
    \begin{itemize}
        \item Description: Process a return transaction
        \item Request Body: \texttt{\{rentalId: UUID, items: Array<\{rentalItemId: UUID, quantity: number\}>\}}
        \item Response: Complete return object with refund amounts
        \item Authentication: Required
        \item Business Logic: Calculates refunds, handles overdue items, restores inventory quantities
    \end{itemize}
    
    \item \textbf{GET /api/returns}
    \begin{itemize}
        \item Description: Retrieve all return transactions
        \item Response: Array of return objects
        \item Authentication: Required
    \end{itemize}
\end{itemize}

\subsubsection{Inventory Endpoints}

\begin{itemize}
    \item \textbf{GET /api/items}
    \begin{itemize}
        \item Description: Retrieve all inventory items
        \item Response: Array of item objects
        \item Authentication: Required
        \item Query Parameters: \texttt{?search=<name>} (search by name), \texttt{?lowStock=<threshold>} (low stock items)
    \end{itemize}
    
    \item \textbf{GET /api/items/\{id\}}
    \begin{itemize}
        \item Description: Retrieve specific item by UUID
        \item Response: Item object
        \item Authentication: Required
    \end{itemize}
    
    \item \textbf{GET /api/items/item-id/\{itemId\}}
    \begin{itemize}
        \item Description: Retrieve item by business ID (integer)
        \item Response: Item object
        \item Authentication: Required
    \end{itemize}
    
    \item \textbf{PUT /api/items/\{id\}/quantity}
    \begin{itemize}
        \item Description: Update item quantity
        \item Request Body: \texttt{\{quantity: number\}}
        \item Response: Updated item object
        \item Authentication: Required (Admin only)
    \end{itemize}
\end{itemize}

\subsubsection{Employee Management Endpoints}

\begin{itemize}
    \item \textbf{GET /api/employees}
    \begin{itemize}
        \item Description: Retrieve all employees
        \item Response: Array of employee objects (without password hashes)
        \item Authentication: Required (Admin only)
    \end{itemize}
    
    \item \textbf{POST /api/employees}
    \begin{itemize}
        \item Description: Create new employee
        \item Request Body: \texttt{\{username: string, firstName: string, lastName: string, position: string, password: string\}}
        \item Response: Created employee object
        \item Authentication: Required (Admin only)
    \end{itemize}
    
    \item \textbf{PUT /api/employees/\{id\}}
    \begin{itemize}
        \item Description: Update employee information
        \item Request Body: Employee fields to update
        \item Response: Updated employee object
        \item Authentication: Required (Admin only)
    \end{itemize}
    
    \item \textbf{DELETE /api/employees/\{id\}}
    \begin{itemize}
        \item Description: Delete employee account
        \item Response: Success message
        \item Authentication: Required (Admin only)
    \end{itemize}
\end{itemize}

\subsubsection{Data Migration Endpoints}

\begin{itemize}
    \item \textbf{POST /api/migration/migrate}
    \begin{itemize}
        \item Description: Migrate data from legacy text files to database
        \item Query Parameters: \texttt{?databasePath=<path>}
        \item Response: Success message with migration statistics
        \item Authentication: Not required (public endpoint for initial setup)
        \item Migrates: Employees, Items, Coupons from legacy files
    \end{itemize}
\end{itemize}

\subsection{Error Handling}

All endpoints return consistent error responses:

\begin{lstlisting}[caption=Error Response Format]
{
  "error": "Error message description",
  "status": "400" or "500"
}
\end{lstlisting}

Common HTTP status codes:
\begin{itemize}
    \item \textbf{200 OK}: Successful request
    \item \textbf{400 Bad Request}: Invalid request data or business logic error
    \item \textbf{401 Unauthorized}: Missing or invalid JWT token
    \item \textbf{403 Forbidden}: Insufficient permissions (e.g., Cashier accessing Admin endpoint)
    \item \textbf{404 Not Found}: Resource not found
    \item \textbf{500 Internal Server Error}: Server-side error
\end{itemize}

\subsection{Request/Response Examples}

Complete API documentation with detailed examples is available in the project repository. The API follows OpenAPI/Swagger conventions and can be explored using tools like Postman or Swagger UI.

\section{Appendix C: Test Results}

\subsection{Test Suite Overview}

The reengineered POS system includes a comprehensive test suite covering unit tests, integration tests, and end-to-end API tests. All tests are configured to run independently using H2 in-memory database, ensuring fast execution and isolation from external dependencies.

\subsection{Backend Test Suite}

\subsubsection{Test Structure}

Backend tests are located in \texttt{pos-backend/src/test/java/com/sgtech/pos/} and organized by layer:

\begin{itemize}
    \item \textbf{Controller Tests}: \texttt{controller/AuthControllerTest.java}
    \begin{itemize}
        \item Tests authentication endpoints
        \item Validates request/response handling
        \item Tests error scenarios
        \item Uses MockMvc for HTTP request simulation
    \end{itemize}
    
    \item \textbf{Service Tests}:
    \begin{itemize}
        \item \texttt{service/SaleServiceTest.java}: Sale processing logic, tax calculation, coupon application
        \item \texttt{service/RentalServiceTest.java}: Rental creation, customer management, due date handling
        \item \texttt{service/ReturnServiceTest.java}: Return processing, refund calculation, overdue tracking
        \item \texttt{service/EmployeeServiceTest.java}: Employee CRUD operations, password hashing
        \item \texttt{service/InventoryServiceTest.java}: Inventory queries, low stock detection, quantity updates
    \end{itemize}
    
    \item \textbf{Repository Tests}:
    \begin{itemize}
        \item \texttt{repository/ItemRepositoryTest.java}: Custom query methods, item lookup by ID
        \item \texttt{repository/CustomerRepositoryTest.java}: Customer search and creation
    \end{itemize}
    
    \item \textbf{Integration Tests}:
    \begin{itemize}
        \item \texttt{integration/SaleIntegrationTest.java}: Complete sale workflow from API call to database persistence
    \end{itemize}
\end{itemize}

\subsubsection{Test Configuration}

All backend tests use the following configuration:

\begin{itemize}
    \item \textbf{Test Profile}: \texttt{@ActiveProfiles("test")} annotation
    \item \textbf{Database}: H2 in-memory database (configured in \texttt{application-test.properties})
    \item \textbf{JWT Configuration}: Test-specific JWT secret and expiration
    \item \textbf{Transaction Management}: \texttt{@Transactional} with rollback after each test
    \item \textbf{Test Data}: Fixtures created in \texttt{@BeforeEach} methods
    \item \textbf{Assertions}: JUnit 5 assertions with Hamcrest matchers
\end{itemize}

\subsubsection{Test Coverage Statistics}

\begin{itemize}
    \item \textbf{Total Test Methods}: 30+ test methods
    \item \textbf{Service Layer Coverage}: 100\% of business logic paths
    \item \textbf{Repository Layer Coverage}: All custom query methods tested
    \item \textbf{Controller Layer Coverage}: Authentication and error handling
    \item \textbf{Integration Coverage}: End-to-end workflows validated
    \item \textbf{Overall Backend Coverage}: Approximately 70-75\%
\end{itemize}

\subsubsection{Key Test Scenarios}

\begin{enumerate}
    \item \textbf{Authentication Tests}:
    \begin{itemize}
        \item Valid login with correct credentials
        \item Invalid login with wrong password
        \item Invalid login with non-existent username
        \item JWT token generation and validation
    \end{itemize}
    
    \item \textbf{Sale Processing Tests}:
    \begin{itemize}
        \item Sale with single item
        \item Sale with multiple items
        \item Sale with coupon discount
        \item Tax calculation (8.25\%)
        \item Inventory quantity updates
        \item Final total calculation
    \end{itemize}
    
    \item \textbf{Rental Processing Tests}:
    \begin{itemize}
        \item Rental creation with new customer
        \item Rental creation with existing customer
        \item Due date validation
        \item Rental total calculation
        \item Inventory updates for rentals
    \end{itemize}
    
    \item \textbf{Return Processing Tests}:
    \begin{itemize}
        \item Return of all rented items
        \item Partial return of items
        \item Overdue item handling
        \item Refund calculation
        \item Inventory restoration
    \end{itemize}
    
    \item \textbf{Inventory Tests}:
    \begin{itemize}
        \item Item search by name
        \item Low stock detection
        \item Quantity updates
        \item Item lookup by ID
    \end{itemize}
    
    \item \textbf{Employee Management Tests}:
    \begin{itemize}
        \item Employee creation with password hashing
        \item Employee update operations
        \item Employee deletion
        \item Username uniqueness validation
    \end{itemize}
\end{enumerate}

\subsection{Frontend Test Suite}

\subsubsection{Test Structure}

Frontend tests are located in \texttt{pos-frontend/src/\_\_tests\_\_/}:

\begin{itemize}
    \item \textbf{Component Tests}: \texttt{Login.test.tsx}
    \begin{itemize}
        \item Form validation
        \item User input handling
        \item Error message display
        \item Navigation after successful login
    \end{itemize}
    
    \item \textbf{Context Tests}: \texttt{AuthContext.test.tsx}
    \begin{itemize}
        \item Authentication state management
        \item Token storage and retrieval
        \item User session management
        \item Logout functionality
    \end{itemize}
    
    \item \textbf{Service Tests}: \texttt{SalesPage.test.tsx}
    \begin{itemize}
        \item API service mocking
        \item Component interaction
        \item User flow validation
    \end{itemize}
\end{itemize}

\subsubsection{Test Configuration}

Frontend tests use:
\begin{itemize}
    \item \textbf{Test Runner}: Vitest (replacing Jest)
    \item \textbf{Testing Library}: React Testing Library
    \item \textbf{Environment}: jsdom for DOM simulation
    \item \textbf{Mocking}: vi.mock() for service layer
    \item \textbf{Setup}: \texttt{src/test/setup.ts} with @testing-library/jest-dom
\end{itemize}

\subsection{API Integration Tests}

\subsubsection{Test Scripts}

Integration test scripts are located in \texttt{test-scripts/}:

\begin{itemize}
    \item \textbf{PowerShell Scripts} (Windows):
    \begin{itemize}
        \item \texttt{integration-test.ps1}: Complete workflow testing
        \item \texttt{test-api.ps1}: Individual endpoint testing
        \item \texttt{migrate-data.ps1}: Data migration validation
    \end{itemize}
    
    \item \textbf{Bash Scripts} (Linux/Mac):
    \begin{itemize}
        \item \texttt{end-to-end-test.sh}: Full system testing
        \item \texttt{test-api.sh}: API endpoint validation
    \end{itemize}
\end{itemize}

\subsubsection{Integration Test Scenarios}

\begin{enumerate}
    \item \textbf{Authentication Flow}:
    \begin{itemize}
        \item Login with valid credentials
        \item Token retrieval and storage
        \item Protected endpoint access
    \end{itemize}
    
    \item \textbf{Sales Workflow}:
    \begin{itemize}
        \item Item selection
        \item Sale creation
        \item Inventory verification
        \item Transaction persistence
    \end{itemize}
    
    \item \textbf{Rental Workflow}:
    \begin{itemize}
        \item Customer creation/lookup
        \item Rental creation
        \item Due date setting
        \item Inventory updates
    \end{itemize}
    
    \item \textbf{Return Workflow}:
    \begin{itemize}
        \item Rental lookup
        \item Return processing
        \item Refund calculation
        \item Inventory restoration
    \end{itemize}
\end{enumerate}

\subsection{Test Execution}

\subsubsection{Running Backend Tests}

\begin{lstlisting}[caption=Backend Test Execution]
cd pos-backend
mvn test
\end{lstlisting}

\subsubsection{Running Frontend Tests}

\begin{lstlisting}[caption=Frontend Test Execution]
cd pos-frontend
npm test
\end{lstlisting}

\subsubsection{Running Integration Tests}

\begin{lstlisting}[caption=Integration Test Execution]
# Windows
.\test-scripts\integration-test.ps1

# Linux/Mac
./test-scripts/end-to-end-test.sh
\end{lstlisting}

\subsection{Test Results Documentation}

Detailed test results and coverage reports are available in:

\begin{itemize}
    \item \textbf{Test Coverage Analysis}: \texttt{TEST\_COVERAGE\_ANALYSIS.md}
    \begin{itemize}
        \item Coverage statistics by layer
        \item Coverage gaps identified
        \item Recommendations for improvement
    \end{itemize}
    
    \item \textbf{Error Fixes}: \texttt{ERROR\_FIXES.md}
    \begin{itemize}
        \item Test configuration issues resolved
        \item H2 database setup
        \item JWT configuration for tests
        \item Spring Data JPA method naming fixes
    \end{itemize}
    
    \item \textbf{Testing Guide}: \texttt{TESTING\_GUIDE.md}
    \begin{itemize}
        \item How to run tests
        \item Test environment setup
        \item Troubleshooting test failures
    \end{itemize}
\end{itemize}

\subsection{Test Quality Metrics}

\begin{itemize}
    \item \textbf{Test Reliability}: All tests pass consistently
    \item \textbf{Test Isolation}: Tests run independently without side effects
    \item \textbf{Test Speed}: Fast execution with in-memory database
    \item \textbf{Test Maintainability}: Well-organized, documented test code
    \item \textbf{Coverage Goals}: Critical business logic paths fully covered
\end{itemize}

All tests are configured to run with H2 in-memory database and include comprehensive coverage of critical business logic paths, ensuring the reliability and maintainability of the reengineered system.

\end{document}

