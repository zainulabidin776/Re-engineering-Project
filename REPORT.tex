\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{float}

\geometry{margin=1in}
\pagestyle{fancy}
\fancyhf{}
\rhead{Software Reengineering Project}
\lhead{SG Technologies POS System}
\cfoot{\thepage}

\titleformat{\section}
{\Large\bfseries}
{}
{0em}
{}[\titlerule]

\lstset{
    language=Java,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    breakatwhitespace=true,
    tabsize=2
}

\title{
    \textbf{Software Reengineering Project}\\
    \large Reengineering Legacy POS System to Modern Web Application
}
\author{
    Muhammad Yousuf Khan (21i-1238)\\
    Zain Ul Abidin (22i-2738)\\
    Abad Naseer (20i-1815)
}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\newpage
\tableofcontents
\newpage

\section{Executive Summary}

This document presents a comprehensive report on the software reengineering project of the SG Technologies Point-of-Sale (POS) system. The project involved transforming a legacy desktop-based Java application into a modern, web-based system following the Software Reengineering Process Model. The reengineered system utilizes Spring Boot for the backend, React with TypeScript for the frontend, and PostgreSQL for data storage.

\subsection{Project Objectives}
\begin{itemize}
    \item Analyze and document the legacy system architecture
    \item Restructure code to improve maintainability
    \item Migrate from file-based storage to relational database
    \item Implement modern web-based architecture
    \item Ensure feature parity with legacy system
    \item Improve security, scalability, and user experience
\end{itemize}

\subsection{Key Achievements}
\begin{itemize}
    \item Successfully completed all 6 phases of reengineering process
    \item Eliminated 130+ lines of duplicate code
    \item Designed normalized database schema with 11 tables
    \item Implemented complete REST API with 15+ endpoints
    \item Built modern React frontend with Material-UI
    \item Achieved 100\% feature parity with legacy system
    \item Created comprehensive test suite with 30+ backend tests and frontend tests
    \item Configured H2 in-memory database for isolated testing
    \item Achieved approximately 60\% overall test coverage
\end{itemize}

\section{Introduction}

\subsection{Project Background}

The SG Technologies POS system was originally developed as a desktop application using Java Swing for the user interface and plain text files for data storage. While functional, the system suffered from several limitations:

\begin{itemize}
    \item \textbf{Single-user limitation}: Desktop application restricted to one user at a time
    \item \textbf{File-based storage}: Data stored in text files without proper relationships
    \item \textbf{Security concerns}: Plain text password storage
    \item \textbf{Maintainability issues}: Code duplication, magic numbers, tight coupling
    \item \textbf{No scalability}: Cannot handle concurrent transactions efficiently
\end{itemize}

\subsection{Reengineering Goals}

The reengineering project aimed to address these limitations by:

\begin{enumerate}
    \item \textbf{Modernizing architecture}: Transition to web-based, multi-user system
    \item \textbf{Improving data management}: Migrate to normalized relational database
    \item \textbf{Enhancing security}: Implement JWT authentication and password hashing
    \item \textbf{Refactoring code}: Eliminate duplication and improve maintainability
    \item \textbf{Improving UX}: Modern web interface with better usability
\end{enumerate}

\section{Reengineering Process Model}

The project followed the Software Reengineering Process Model, which consists of six distinct phases:

\subsection{Phase 1: Inventory Analysis}

\subsubsection{Objectives}
The inventory analysis phase involved cataloging all assets of the legacy system, including source code files, data files, documentation, and dependencies.

\subsubsection{Findings}
\begin{itemize}
    \item \textbf{Source Code}: 20 Java classes totaling approximately 3,000 lines of code
    \item \textbf{Data Files}: 9 text-based database files storing different entities
    \item \textbf{Test Coverage}: Less than 5\% test coverage
    \item \textbf{Dependencies}: Minimal external dependencies, mostly Java standard library
\end{itemize}

\subsubsection{Asset Classification}
Assets were classified into three categories:
\begin{itemize}
    \item \textbf{Keep}: Core business logic, domain models
    \item \textbf{Refactor}: Classes with code smells, duplicate code
    \item \textbf{Replace}: File I/O operations, Swing UI components
\end{itemize}

\subsection{Phase 2: Document Restructuring}

\subsubsection{Objectives}
Reorganize and enhance documentation to support the reengineering effort.

\subsubsection{Deliverables}
\begin{itemize}
    \item Data dictionary for all file formats
    \item Operational scenarios and use cases
    \item Architecture diagrams
    \item API documentation structure
\end{itemize}

\subsection{Phase 3: Reverse Engineering}

\subsubsection{Architecture Analysis}

The legacy system followed a layered architecture with the following components:

\begin{enumerate}
    \item \textbf{Presentation Layer}: Swing-based GUI components
    \item \textbf{Business Logic Layer}: Core POS operations (Sales, Rentals, Returns)
    \item \textbf{Data Access Layer}: File I/O operations for data persistence
\end{enumerate}

\subsubsection{Code Smells Identified}

\begin{enumerate}
    \item \textbf{God Classes}: POSSystem, PointOfSale, Management classes with excessive responsibilities
    \item \textbf{Long Methods}: Methods exceeding 80 lines of code
    \item \textbf{Code Duplication}: deleteTempItem method duplicated in 3 classes
    \item \textbf{Magic Numbers}: Hardcoded values throughout the codebase
    \item \textbf{Feature Envy}: Classes accessing data from other classes excessively
    \item \textbf{Data Clumps}: Related data not grouped into objects
    \item \textbf{Primitive Obsession}: Using primitives instead of value objects
    \item \textbf{Inappropriate Intimacy}: Classes knowing too much about each other
    \item \textbf{Lazy Class}: Classes with minimal functionality
    \item \textbf{Speculative Generality}: Over-abstracted code
\end{enumerate}

\subsubsection{Data Smells Identified}

\begin{itemize}
    \item \textbf{Denormalized Data}: Customer and rental data mixed in single file
    \item \textbf{No Referential Integrity}: No foreign key relationships
    \item \textbf{Inconsistent Formats}: Mix of space and comma delimiters
    \item \textbf{No Data Validation}: No constraints on data values
\end{itemize}

\subsection{Phase 4: Code Restructuring}

\subsubsection{Refactoring Activities}

Ten major refactorings were performed:

\begin{enumerate}
    \item \textbf{Extract Constants Class}: Centralized 20+ magic numbers and strings
    \item \textbf{Extract SystemUtils Class}: Consolidated OS detection and line separator logic
    \item \textbf{Apply Constants to POSSystem}: Replaced hardcoded file paths
    \item \textbf{Apply Constants to PointOfSale}: Replaced magic values
    \item \textbf{Apply Constants to POS}: Updated sale-related constants
    \item \textbf{Apply Constants to POR}: Updated rental-related constants
    \item \textbf{Apply Constants to POH}: Updated return-related constants
    \item \textbf{Apply Constants to Management}: Updated user database constants
    \item \textbf{Apply Constants to EmployeeManagement}: Updated employee constants
    \item \textbf{Extract Duplicate Method}: Consolidated deleteTempItem into base class
\end{enumerate}

\subsubsection{Results}

\begin{itemize}
    \item Eliminated approximately 130 lines of duplicate code
    \item Centralized all magic values in Constants class
    \item Improved code maintainability and readability
    \item Zero behavior changes (safe refactorings)
    \item All tests passing after refactoring
\end{itemize}

\subsection{Phase 5: Data Restructuring}

\subsubsection{Database Design}

A normalized PostgreSQL schema was designed with 11 tables:

\begin{enumerate}
    \item \textbf{employees}: Employee accounts and authentication
    \item \textbf{items}: Inventory items with pricing
    \item \textbf{customers}: Customer information
    \item \textbf{coupons}: Discount codes
    \item \textbf{sales}: Sales transactions
    \item \textbf{sale\_items}: Items in each sale
    \item \textbf{rentals}: Rental transactions
    \item \textbf{rental\_items}: Items in each rental
    \item \textbf{returns}: Return transactions
    \item \textbf{return\_items}: Items in each return
    \item \textbf{audit\_logs}: System audit trail
\end{enumerate}

\subsubsection{Normalization}

The schema follows Third Normal Form (3NF):
\begin{itemize}
    \item No repeating groups
    \item No partial dependencies
    \item No transitive dependencies
    \item Proper foreign key relationships
\end{itemize}

\subsubsection{Data Migration Strategy}

A migration utility was developed to:
\begin{enumerate}
    \item Parse legacy text files
    \item Transform data to normalized structure
    \item Load data into PostgreSQL
    \item Validate data integrity
\end{enumerate}

\subsection{Phase 6: Forward Engineering}

\subsubsection{Technology Stack Selection}

\textbf{Backend:}
\begin{itemize}
    \item Spring Boot 3.2.0
    \item Spring Data JPA
    \item Spring Security with JWT
    \item PostgreSQL
    \item Maven
\end{itemize}

\textbf{Frontend:}
\begin{itemize}
    \item React 18.2
    \item TypeScript 5.3
    \item Material-UI 5.14
    \item Vite 5.0
    \item Axios 1.6
\end{itemize}

\subsubsection{Architecture Design}

The reengineered system follows a layered architecture:

\begin{enumerate}
    \item \textbf{Presentation Layer}: React components with Material-UI
    \item \textbf{API Layer}: Spring Boot REST controllers
    \item \textbf{Business Logic Layer}: Spring services
    \item \textbf{Data Access Layer}: Spring Data JPA repositories
    \item \textbf{Database Layer}: PostgreSQL
\end{enumerate}

\subsubsection{Key Features Implemented}

\begin{itemize}
    \item JWT-based authentication
    \item Role-based access control (Admin/Cashier)
    \item Sales processing with tax and coupon support
    \item Rental management with customer lookup
    \item Return processing with overdue tracking
    \item Inventory management
    \item Employee management (Admin only)
\end{itemize}

\section{Implementation Details}

\subsection{Backend Implementation}

\subsubsection{Entity Design}

JPA entities were created for all database tables with proper relationships:

\begin{lstlisting}[caption=Employee Entity Example]
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    
    @Column(unique = true, nullable = false)
    private String username;
    
    @Column(nullable = false)
    private String position; // Admin or Cashier
    
    @Column(name = "password_hash", nullable = false)
    private String passwordHash;
    
    // Getters and setters
}
\end{lstlisting}

\subsubsection{Service Layer}

Business logic was implemented in service classes:

\begin{lstlisting}[caption=Sale Service Example]
@Service
public class SaleService {
    @Transactional
    public Sale processSale(UUID employeeId, SaleRequest request) {
        // Calculate totals
        // Update inventory
        // Apply tax and discounts
        // Save transaction
    }
}
\end{lstlisting}

\subsubsection{API Endpoints}

RESTful endpoints were created for all operations:

\begin{itemize}
    \item \texttt{POST /api/auth/login} - Authentication
    \item \texttt{POST /api/sales} - Process sale
    \item \texttt{POST /api/rentals} - Process rental
    \item \texttt{POST /api/returns} - Process return
    \item \texttt{GET /api/items} - Get inventory
    \item \texttt{GET /api/employees} - Employee management
\end{itemize}

\subsection{Frontend Implementation}

\subsubsection{Component Structure}

React components were organized into:
\begin{itemize}
    \item \textbf{Pages}: Login, CashierDashboard, AdminDashboard
    \item \textbf{Components}: SalesPage, RentalsPage, ReturnsPage, etc.
    \item \textbf{Services}: API service layer
    \item \textbf{Context}: Authentication context
\end{itemize}

\subsubsection{Authentication Flow}

\begin{enumerate}
    \item User enters credentials on login page
    \item Frontend sends POST request to /api/auth/login
    \item Backend validates credentials and returns JWT token
    \item Token stored in localStorage
    \item Token included in all subsequent API requests
    \item Protected routes check authentication status
\end{enumerate}

\section{Testing}

\subsection{Testing Strategy}

A comprehensive testing strategy was implemented covering unit tests, integration tests, and end-to-end API tests. The test suite ensures reliability and maintainability of the reengineered system.

\subsection{Backend Testing}

JUnit 5 tests were created with comprehensive coverage:

\begin{itemize}
    \item \textbf{Controller Tests}: Authentication controller with MockMvc
    \item \textbf{Service Tests}: Sale, Rental, Return, Employee, and Inventory services
    \item \textbf{Repository Tests}: Item and Customer repository queries
    \item \textbf{Integration Tests}: Complete sale workflow with coupon application
\end{itemize}

\subsubsection{Test Configuration}

Tests are configured to use H2 in-memory database for isolation:
\begin{itemize}
    \item H2 database dependency added for test scope
    \item Test profile configuration (\texttt{application-test.properties})
    \item \texttt{@ActiveProfiles("test")} annotation on all test classes
    \item JWT configuration for test environment
    \item Transaction rollback after each test
\end{itemize}

\subsubsection{Test Coverage}

The backend test suite includes:
\begin{itemize}
    \item 30+ test methods covering all critical paths
    \item Service layer: 100\% coverage of business logic
    \item Repository layer: All query methods tested
    \item Controller layer: Authentication and error handling
    \item Integration tests: End-to-end workflows
\end{itemize}

\subsection{Frontend Testing}

React Testing Library with Vitest tests were created for:

\begin{itemize}
    \item \textbf{Component Tests}: Login component with form validation
    \item \textbf{Context Tests}: Authentication context and state management
    \item \textbf{Service Tests}: API service layer mocking
    \item \textbf{Integration Tests}: Component interaction and user flows
\end{itemize}

\subsubsection{Test Configuration}

Frontend tests use:
\begin{itemize}
    \item Vitest as the test runner (replacing Jest)
    \item React Testing Library for component testing
    \item jsdom environment for DOM simulation
    \item Mock service layer for API calls
\end{itemize}

\subsection{API Testing}

Comprehensive API testing scripts were created:

\begin{itemize}
    \item \textbf{PowerShell Scripts}: Windows-compatible integration tests
    \item \textbf{Bash Scripts}: Linux/Mac end-to-end test suites
    \item \textbf{Integration Tests}: Complete workflows (login, sales, rentals, returns)
    \item \textbf{Manual Testing}: Postman collection for API exploration
\end{itemize}

\subsubsection{Test Scenarios}

API tests cover:
\begin{itemize}
    \item Authentication and authorization flows
    \item Sales processing with multiple items and coupons
    \item Rental creation and customer management
    \item Return processing with inventory restoration
    \item Inventory management operations
    \item Employee management (Admin only)
\end{itemize}

\section{Results and Improvements}

\subsection{Code Quality Improvements}

\begin{itemize}
    \item \textbf{Code Duplication}: Reduced by 130+ lines
    \item \textbf{Maintainability}: Improved through centralized constants
    \item \textbf{Test Coverage}: Increased from <5\% to approximately 60\% overall coverage
    \begin{itemize}
        \item Backend: 30+ test methods covering services, controllers, and repositories
        \item Frontend: Component and context tests with Vitest
        \item Integration: End-to-end API test scripts
    \end{itemize}
    \item \textbf{Documentation}: 10+ comprehensive markdown documents
    \item \textbf{Test Infrastructure}: H2 in-memory database for isolated testing
\end{itemize}

\subsection{Architecture Improvements}

\begin{itemize}
    \item \textbf{Scalability}: Multi-user web application vs. single-user desktop
    \item \textbf{Maintainability}: Layered architecture with clear separation
    \item \textbf{Testability}: Dependency injection enables unit testing
    \item \textbf{Extensibility}: Easy to add new features
\end{itemize}

\subsection{Data Management Improvements}

\begin{itemize}
    \item \textbf{Normalization}: Proper relational structure
    \item \textbf{Integrity}: Foreign key constraints
    \item \textbf{Concurrency}: Database transactions
    \item \textbf{Performance}: Indexed queries
\end{itemize}

\subsection{Security Improvements}

\begin{itemize}
    \item \textbf{Authentication}: JWT tokens vs. plain text
    \item \textbf{Password Storage}: BCrypt hashing
    \item \textbf{Authorization}: Role-based access control
    \item \textbf{API Security}: Protected endpoints
\end{itemize}

\section{Challenges and Solutions}

\subsection{Challenge 1: Data Migration}

\textbf{Problem}: Migrating data from text files to normalized database.

\textbf{Solution}: Created DataMigrationUtil class to parse files and transform data.

\subsection{Challenge 2: Legacy Code Understanding}

\textbf{Problem}: Understanding legacy code structure and business logic.

\textbf{Solution}: Comprehensive reverse engineering analysis and documentation.

\subsection{Challenge 3: Feature Parity}

\textbf{Problem}: Ensuring all legacy features work in new system.

\textbf{Solution}: Detailed feature mapping and comprehensive testing.

\subsection{Challenge 4: Test Configuration}

\textbf{Problem}: Initial test failures due to ApplicationContext loading issues. Tests were attempting to connect to PostgreSQL database which may not be available during test execution.

\textbf{Solution}: 
\begin{itemize}
    \item Configured H2 in-memory database for test environment
    \item Created test profile with \texttt{application-test.properties}
    \item Added \texttt{@ActiveProfiles("test")} to all test classes
    \item Configured JWT properties for test environment
    \item Tests now run independently without external database dependency
\end{itemize}

\subsection{Challenge 5: Spring Data JPA Query Method Naming}

\textbf{Problem}: Repository method \texttt{findByQuantityLessThanOrEqual} caused ApplicationContext loading failure with error: "No property 'equal' found for type 'Item'".

\textbf{Solution}: 
\begin{itemize}
    \item Identified that Spring Data JPA does not support \texttt{LessThanOrEqual} keyword
    \item Changed method name to \texttt{findByQuantityLessThanEqual} (removed "Or")
    \item Updated service layer to use corrected method name
    \item All tests now pass successfully
\end{itemize}

\section{Conclusion}

The software reengineering project successfully transformed the legacy POS system into a modern, web-based application. All six phases of the reengineering process were completed, resulting in:

\begin{itemize}
    \item Improved code quality and maintainability
    \item Modern web-based architecture
    \item Secure authentication and authorization
    \item Normalized database structure
    \item Enhanced user experience
    \item Comprehensive documentation
\end{itemize}

The reengineered system maintains feature parity with the legacy system while providing significant improvements in scalability, security, and maintainability.

\section{Future Work}

Potential enhancements for future iterations:

\begin{itemize}
    \item Increase test coverage to 80\%+ with additional edge case tests
    \item Implement reporting and analytics features
    \item Add mobile application support (React Native)
    \item Implement real-time inventory updates with WebSockets
    \item Add barcode scanning support
    \item Implement loyalty program features
    \item Add automated CI/CD pipeline with test execution
    \item Implement performance testing and optimization
    \item Add comprehensive API documentation with Swagger/OpenAPI
\end{itemize}

\section{References}

\begin{itemize}
    \item Software Reengineering Process Model
    \item Spring Boot Documentation: \url{https://spring.io/projects/spring-boot}
    \item React Documentation: \url{https://react.dev}
    \item PostgreSQL Documentation: \url{https://www.postgresql.org/docs}
    \item Project Repository: \url{https://github.com/zainulabidin776/Re-engineering-Project}
\end{itemize}

\appendix

\section{Appendix A: Database Schema}

The complete database schema DDL is available in \texttt{database/schema.sql}. This file contains the Data Definition Language (DDL) script for the PostgreSQL database schema, including all 11 tables, their relationships, constraints, and indexes. The schema follows Third Normal Form (3NF) normalization principles and includes proper foreign key relationships for data integrity.

\section{Appendix B: API Documentation}

Complete API documentation is available in the project repository. The documentation includes detailed descriptions of all REST API endpoints, request/response formats, authentication requirements, and example usage. API endpoints cover authentication, sales processing, rental management, return processing, inventory operations, and employee management. All endpoints follow RESTful conventions and include proper error handling.

\section{Appendix C: Test Results}

Test execution results and coverage reports are available in the test directories. The test suite includes:
\begin{itemize}
    \item Backend test results in \texttt{pos-backend/src/test/java/}
    \item Frontend test results in \texttt{pos-frontend/src/\_\_tests\_\_/}
    \item Integration test scripts in \texttt{test-scripts/}
    \item Test coverage analysis in \texttt{TEST\_COVERAGE\_ANALYSIS.md}
    \item Error fixes and test configuration in \texttt{ERROR\_FIXES.md}
\end{itemize}

All tests are configured to run with H2 in-memory database and include comprehensive coverage of critical business logic paths.

\end{document}

